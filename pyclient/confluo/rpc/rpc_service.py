#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def register_handler(self):
        """
        Management ops *
        """
        pass

    def deregister_handler(self):
        pass

    def create_atomic_multilog(self, name, schema, mode):
        """
        Parameters:
         - name
         - schema
         - mode
        """
        pass

    def get_atomic_multilog_info(self, name):
        """
        Parameters:
         - name
        """
        pass

    def remove_atomic_multilog(self, multilog_id):
        """
        Parameters:
         - multilog_id
        """
        pass

    def add_index(self, multilog_id, field_name, bucket_size):
        """
        Parameters:
         - multilog_id
         - field_name
         - bucket_size
        """
        pass

    def remove_index(self, multilog_id, field_name):
        """
        Parameters:
         - multilog_id
         - field_name
        """
        pass

    def add_filter(self, multilog_id, filter_name, filter_expr):
        """
        Parameters:
         - multilog_id
         - filter_name
         - filter_expr
        """
        pass

    def remove_filter(self, multilog_id, filter_name):
        """
        Parameters:
         - multilog_id
         - filter_name
        """
        pass

    def add_aggregate(self, mutlilog_id, aggregate_name, filter_name, aggregate_expr):
        """
        Parameters:
         - mutlilog_id
         - aggregate_name
         - filter_name
         - aggregate_expr
        """
        pass

    def remove_aggregate(self, multilog_id, aggregate_name):
        """
        Parameters:
         - multilog_id
         - aggregate_name
        """
        pass

    def add_trigger(self, multilog_id, trigger_name, trigger_expr):
        """
        Parameters:
         - multilog_id
         - trigger_name
         - trigger_expr
        """
        pass

    def remove_trigger(self, multilog_id, trigger_name):
        """
        Parameters:
         - multilog_id
         - trigger_name
        """
        pass

    def append(self, multilog_id, data):
        """
        Query ops *

        Parameters:
         - multilog_id
         - data
        """
        pass

    def append_json(self, multilog_id, data):
        """
        Parameters:
         - multilog_id
         - data
        """
        pass

    def append_batch(self, multilog_id, batch):
        """
        Parameters:
         - multilog_id
         - batch
        """
        pass

    def read(self, multilog_id, offset, nrecords):
        """
        Parameters:
         - multilog_id
         - offset
         - nrecords
        """
        pass

    def read_json(self, multilog_id, offset, nrecords):
        """
        Parameters:
         - multilog_id
         - offset
         - nrecords
        """
        pass

    def query_aggregate(self, multilog_id, aggregate_name, begin_ms, end_ms):
        """
        Parameters:
         - multilog_id
         - aggregate_name
         - begin_ms
         - end_ms
        """
        pass

    def adhoc_aggregate(self, multilog_id, aggregate_expr, filter_expr):
        """
        Parameters:
         - multilog_id
         - aggregate_expr
         - filter_expr
        """
        pass

    def adhoc_filter(self, multilog_id, filter_expr):
        """
        Parameters:
         - multilog_id
         - filter_expr
        """
        pass

    def predef_filter(self, multilog_id, filter_name, begin_ms, end_ms):
        """
        Parameters:
         - multilog_id
         - filter_name
         - begin_ms
         - end_ms
        """
        pass

    def combined_filter(self, multilog_id, filter_name, filter_expr, begin_ms, end_ms):
        """
        Parameters:
         - multilog_id
         - filter_name
         - filter_expr
         - begin_ms
         - end_ms
        """
        pass

    def alerts_by_time(self, multilog_id, begin_ms, end_ms):
        """
        Parameters:
         - multilog_id
         - begin_ms
         - end_ms
        """
        pass

    def alerts_by_trigger_and_time(self, multilog_id, trigger_name, begin_ms, end_ms):
        """
        Parameters:
         - multilog_id
         - trigger_name
         - begin_ms
         - end_ms
        """
        pass

    def get_more(self, multilog_id, desc):
        """
        Parameters:
         - multilog_id
         - desc
        """
        pass

    def num_records(self, multilog_id):
        """
        Parameters:
         - multilog_id
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def register_handler(self):
        """
        Management ops *
        """
        self.send_register_handler()
        self.recv_register_handler()

    def send_register_handler(self):
        self._oprot.writeMessageBegin('register_handler', TMessageType.CALL, self._seqid)
        args = register_handler_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_register_handler(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = register_handler_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def deregister_handler(self):
        self.send_deregister_handler()
        self.recv_deregister_handler()

    def send_deregister_handler(self):
        self._oprot.writeMessageBegin('deregister_handler', TMessageType.CALL, self._seqid)
        args = deregister_handler_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deregister_handler(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deregister_handler_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def create_atomic_multilog(self, name, schema, mode):
        """
        Parameters:
         - name
         - schema
         - mode
        """
        self.send_create_atomic_multilog(name, schema, mode)
        return self.recv_create_atomic_multilog()

    def send_create_atomic_multilog(self, name, schema, mode):
        self._oprot.writeMessageBegin('create_atomic_multilog', TMessageType.CALL, self._seqid)
        args = create_atomic_multilog_args()
        args.name = name
        args.schema = schema
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_atomic_multilog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_atomic_multilog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_atomic_multilog failed: unknown result")

    def get_atomic_multilog_info(self, name):
        """
        Parameters:
         - name
        """
        self.send_get_atomic_multilog_info(name)
        return self.recv_get_atomic_multilog_info()

    def send_get_atomic_multilog_info(self, name):
        self._oprot.writeMessageBegin('get_atomic_multilog_info', TMessageType.CALL, self._seqid)
        args = get_atomic_multilog_info_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_atomic_multilog_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_atomic_multilog_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_atomic_multilog_info failed: unknown result")

    def remove_atomic_multilog(self, multilog_id):
        """
        Parameters:
         - multilog_id
        """
        self.send_remove_atomic_multilog(multilog_id)
        self.recv_remove_atomic_multilog()

    def send_remove_atomic_multilog(self, multilog_id):
        self._oprot.writeMessageBegin('remove_atomic_multilog', TMessageType.CALL, self._seqid)
        args = remove_atomic_multilog_args()
        args.multilog_id = multilog_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_atomic_multilog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_atomic_multilog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def add_index(self, multilog_id, field_name, bucket_size):
        """
        Parameters:
         - multilog_id
         - field_name
         - bucket_size
        """
        self.send_add_index(multilog_id, field_name, bucket_size)
        self.recv_add_index()

    def send_add_index(self, multilog_id, field_name, bucket_size):
        self._oprot.writeMessageBegin('add_index', TMessageType.CALL, self._seqid)
        args = add_index_args()
        args.multilog_id = multilog_id
        args.field_name = field_name
        args.bucket_size = bucket_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_index(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_index_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def remove_index(self, multilog_id, field_name):
        """
        Parameters:
         - multilog_id
         - field_name
        """
        self.send_remove_index(multilog_id, field_name)
        self.recv_remove_index()

    def send_remove_index(self, multilog_id, field_name):
        self._oprot.writeMessageBegin('remove_index', TMessageType.CALL, self._seqid)
        args = remove_index_args()
        args.multilog_id = multilog_id
        args.field_name = field_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_index(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_index_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def add_filter(self, multilog_id, filter_name, filter_expr):
        """
        Parameters:
         - multilog_id
         - filter_name
         - filter_expr
        """
        self.send_add_filter(multilog_id, filter_name, filter_expr)
        self.recv_add_filter()

    def send_add_filter(self, multilog_id, filter_name, filter_expr):
        self._oprot.writeMessageBegin('add_filter', TMessageType.CALL, self._seqid)
        args = add_filter_args()
        args.multilog_id = multilog_id
        args.filter_name = filter_name
        args.filter_expr = filter_expr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def remove_filter(self, multilog_id, filter_name):
        """
        Parameters:
         - multilog_id
         - filter_name
        """
        self.send_remove_filter(multilog_id, filter_name)
        self.recv_remove_filter()

    def send_remove_filter(self, multilog_id, filter_name):
        self._oprot.writeMessageBegin('remove_filter', TMessageType.CALL, self._seqid)
        args = remove_filter_args()
        args.multilog_id = multilog_id
        args.filter_name = filter_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def add_aggregate(self, mutlilog_id, aggregate_name, filter_name, aggregate_expr):
        """
        Parameters:
         - mutlilog_id
         - aggregate_name
         - filter_name
         - aggregate_expr
        """
        self.send_add_aggregate(mutlilog_id, aggregate_name, filter_name, aggregate_expr)
        self.recv_add_aggregate()

    def send_add_aggregate(self, mutlilog_id, aggregate_name, filter_name, aggregate_expr):
        self._oprot.writeMessageBegin('add_aggregate', TMessageType.CALL, self._seqid)
        args = add_aggregate_args()
        args.mutlilog_id = mutlilog_id
        args.aggregate_name = aggregate_name
        args.filter_name = filter_name
        args.aggregate_expr = aggregate_expr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_aggregate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_aggregate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def remove_aggregate(self, multilog_id, aggregate_name):
        """
        Parameters:
         - multilog_id
         - aggregate_name
        """
        self.send_remove_aggregate(multilog_id, aggregate_name)
        self.recv_remove_aggregate()

    def send_remove_aggregate(self, multilog_id, aggregate_name):
        self._oprot.writeMessageBegin('remove_aggregate', TMessageType.CALL, self._seqid)
        args = remove_aggregate_args()
        args.multilog_id = multilog_id
        args.aggregate_name = aggregate_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_aggregate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_aggregate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def add_trigger(self, multilog_id, trigger_name, trigger_expr):
        """
        Parameters:
         - multilog_id
         - trigger_name
         - trigger_expr
        """
        self.send_add_trigger(multilog_id, trigger_name, trigger_expr)
        self.recv_add_trigger()

    def send_add_trigger(self, multilog_id, trigger_name, trigger_expr):
        self._oprot.writeMessageBegin('add_trigger', TMessageType.CALL, self._seqid)
        args = add_trigger_args()
        args.multilog_id = multilog_id
        args.trigger_name = trigger_name
        args.trigger_expr = trigger_expr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_trigger(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_trigger_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def remove_trigger(self, multilog_id, trigger_name):
        """
        Parameters:
         - multilog_id
         - trigger_name
        """
        self.send_remove_trigger(multilog_id, trigger_name)
        self.recv_remove_trigger()

    def send_remove_trigger(self, multilog_id, trigger_name):
        self._oprot.writeMessageBegin('remove_trigger', TMessageType.CALL, self._seqid)
        args = remove_trigger_args()
        args.multilog_id = multilog_id
        args.trigger_name = trigger_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_trigger(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_trigger_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ex is not None:
            raise result.ex
        return

    def append(self, multilog_id, data):
        """
        Query ops *

        Parameters:
         - multilog_id
         - data
        """
        self.send_append(multilog_id, data)
        return self.recv_append()

    def send_append(self, multilog_id, data):
        self._oprot.writeMessageBegin('append', TMessageType.CALL, self._seqid)
        args = append_args()
        args.multilog_id = multilog_id
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append failed: unknown result")

    def append_json(self, multilog_id, data):
        """
        Parameters:
         - multilog_id
         - data
        """
        self.send_append_json(multilog_id, data)
        return self.recv_append_json()

    def send_append_json(self, multilog_id, data):
        self._oprot.writeMessageBegin('append_json', TMessageType.CALL, self._seqid)
        args = append_json_args()
        args.multilog_id = multilog_id
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_json(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_json_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_json failed: unknown result")

    def append_batch(self, multilog_id, batch):
        """
        Parameters:
         - multilog_id
         - batch
        """
        self.send_append_batch(multilog_id, batch)
        return self.recv_append_batch()

    def send_append_batch(self, multilog_id, batch):
        self._oprot.writeMessageBegin('append_batch', TMessageType.CALL, self._seqid)
        args = append_batch_args()
        args.multilog_id = multilog_id
        args.batch = batch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_batch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_batch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_batch failed: unknown result")

    def read(self, multilog_id, offset, nrecords):
        """
        Parameters:
         - multilog_id
         - offset
         - nrecords
        """
        self.send_read(multilog_id, offset, nrecords)
        return self.recv_read()

    def send_read(self, multilog_id, offset, nrecords):
        self._oprot.writeMessageBegin('read', TMessageType.CALL, self._seqid)
        args = read_args()
        args.multilog_id = multilog_id
        args.offset = offset
        args.nrecords = nrecords
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read failed: unknown result")

    def read_json(self, multilog_id, offset, nrecords):
        """
        Parameters:
         - multilog_id
         - offset
         - nrecords
        """
        self.send_read_json(multilog_id, offset, nrecords)
        return self.recv_read_json()

    def send_read_json(self, multilog_id, offset, nrecords):
        self._oprot.writeMessageBegin('read_json', TMessageType.CALL, self._seqid)
        args = read_json_args()
        args.multilog_id = multilog_id
        args.offset = offset
        args.nrecords = nrecords
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_json(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_json_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_json failed: unknown result")

    def query_aggregate(self, multilog_id, aggregate_name, begin_ms, end_ms):
        """
        Parameters:
         - multilog_id
         - aggregate_name
         - begin_ms
         - end_ms
        """
        self.send_query_aggregate(multilog_id, aggregate_name, begin_ms, end_ms)
        return self.recv_query_aggregate()

    def send_query_aggregate(self, multilog_id, aggregate_name, begin_ms, end_ms):
        self._oprot.writeMessageBegin('query_aggregate', TMessageType.CALL, self._seqid)
        args = query_aggregate_args()
        args.multilog_id = multilog_id
        args.aggregate_name = aggregate_name
        args.begin_ms = begin_ms
        args.end_ms = end_ms
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_aggregate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_aggregate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_aggregate failed: unknown result")

    def adhoc_aggregate(self, multilog_id, aggregate_expr, filter_expr):
        """
        Parameters:
         - multilog_id
         - aggregate_expr
         - filter_expr
        """
        self.send_adhoc_aggregate(multilog_id, aggregate_expr, filter_expr)
        return self.recv_adhoc_aggregate()

    def send_adhoc_aggregate(self, multilog_id, aggregate_expr, filter_expr):
        self._oprot.writeMessageBegin('adhoc_aggregate', TMessageType.CALL, self._seqid)
        args = adhoc_aggregate_args()
        args.multilog_id = multilog_id
        args.aggregate_expr = aggregate_expr
        args.filter_expr = filter_expr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_adhoc_aggregate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = adhoc_aggregate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "adhoc_aggregate failed: unknown result")

    def adhoc_filter(self, multilog_id, filter_expr):
        """
        Parameters:
         - multilog_id
         - filter_expr
        """
        self.send_adhoc_filter(multilog_id, filter_expr)
        return self.recv_adhoc_filter()

    def send_adhoc_filter(self, multilog_id, filter_expr):
        self._oprot.writeMessageBegin('adhoc_filter', TMessageType.CALL, self._seqid)
        args = adhoc_filter_args()
        args.multilog_id = multilog_id
        args.filter_expr = filter_expr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_adhoc_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = adhoc_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "adhoc_filter failed: unknown result")

    def predef_filter(self, multilog_id, filter_name, begin_ms, end_ms):
        """
        Parameters:
         - multilog_id
         - filter_name
         - begin_ms
         - end_ms
        """
        self.send_predef_filter(multilog_id, filter_name, begin_ms, end_ms)
        return self.recv_predef_filter()

    def send_predef_filter(self, multilog_id, filter_name, begin_ms, end_ms):
        self._oprot.writeMessageBegin('predef_filter', TMessageType.CALL, self._seqid)
        args = predef_filter_args()
        args.multilog_id = multilog_id
        args.filter_name = filter_name
        args.begin_ms = begin_ms
        args.end_ms = end_ms
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_predef_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = predef_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "predef_filter failed: unknown result")

    def combined_filter(self, multilog_id, filter_name, filter_expr, begin_ms, end_ms):
        """
        Parameters:
         - multilog_id
         - filter_name
         - filter_expr
         - begin_ms
         - end_ms
        """
        self.send_combined_filter(multilog_id, filter_name, filter_expr, begin_ms, end_ms)
        return self.recv_combined_filter()

    def send_combined_filter(self, multilog_id, filter_name, filter_expr, begin_ms, end_ms):
        self._oprot.writeMessageBegin('combined_filter', TMessageType.CALL, self._seqid)
        args = combined_filter_args()
        args.multilog_id = multilog_id
        args.filter_name = filter_name
        args.filter_expr = filter_expr
        args.begin_ms = begin_ms
        args.end_ms = end_ms
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_combined_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = combined_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "combined_filter failed: unknown result")

    def alerts_by_time(self, multilog_id, begin_ms, end_ms):
        """
        Parameters:
         - multilog_id
         - begin_ms
         - end_ms
        """
        self.send_alerts_by_time(multilog_id, begin_ms, end_ms)
        return self.recv_alerts_by_time()

    def send_alerts_by_time(self, multilog_id, begin_ms, end_ms):
        self._oprot.writeMessageBegin('alerts_by_time', TMessageType.CALL, self._seqid)
        args = alerts_by_time_args()
        args.multilog_id = multilog_id
        args.begin_ms = begin_ms
        args.end_ms = end_ms
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alerts_by_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alerts_by_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "alerts_by_time failed: unknown result")

    def alerts_by_trigger_and_time(self, multilog_id, trigger_name, begin_ms, end_ms):
        """
        Parameters:
         - multilog_id
         - trigger_name
         - begin_ms
         - end_ms
        """
        self.send_alerts_by_trigger_and_time(multilog_id, trigger_name, begin_ms, end_ms)
        return self.recv_alerts_by_trigger_and_time()

    def send_alerts_by_trigger_and_time(self, multilog_id, trigger_name, begin_ms, end_ms):
        self._oprot.writeMessageBegin('alerts_by_trigger_and_time', TMessageType.CALL, self._seqid)
        args = alerts_by_trigger_and_time_args()
        args.multilog_id = multilog_id
        args.trigger_name = trigger_name
        args.begin_ms = begin_ms
        args.end_ms = end_ms
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alerts_by_trigger_and_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alerts_by_trigger_and_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "alerts_by_trigger_and_time failed: unknown result")

    def get_more(self, multilog_id, desc):
        """
        Parameters:
         - multilog_id
         - desc
        """
        self.send_get_more(multilog_id, desc)
        return self.recv_get_more()

    def send_get_more(self, multilog_id, desc):
        self._oprot.writeMessageBegin('get_more', TMessageType.CALL, self._seqid)
        args = get_more_args()
        args.multilog_id = multilog_id
        args.desc = desc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_more(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_more_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_more failed: unknown result")

    def num_records(self, multilog_id):
        """
        Parameters:
         - multilog_id
        """
        self.send_num_records(multilog_id)
        return self.recv_num_records()

    def send_num_records(self, multilog_id):
        self._oprot.writeMessageBegin('num_records', TMessageType.CALL, self._seqid)
        args = num_records_args()
        args.multilog_id = multilog_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_num_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = num_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "num_records failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["register_handler"] = Processor.process_register_handler
        self._processMap["deregister_handler"] = Processor.process_deregister_handler
        self._processMap["create_atomic_multilog"] = Processor.process_create_atomic_multilog
        self._processMap["get_atomic_multilog_info"] = Processor.process_get_atomic_multilog_info
        self._processMap["remove_atomic_multilog"] = Processor.process_remove_atomic_multilog
        self._processMap["add_index"] = Processor.process_add_index
        self._processMap["remove_index"] = Processor.process_remove_index
        self._processMap["add_filter"] = Processor.process_add_filter
        self._processMap["remove_filter"] = Processor.process_remove_filter
        self._processMap["add_aggregate"] = Processor.process_add_aggregate
        self._processMap["remove_aggregate"] = Processor.process_remove_aggregate
        self._processMap["add_trigger"] = Processor.process_add_trigger
        self._processMap["remove_trigger"] = Processor.process_remove_trigger
        self._processMap["append"] = Processor.process_append
        self._processMap["append_json"] = Processor.process_append_json
        self._processMap["append_batch"] = Processor.process_append_batch
        self._processMap["read"] = Processor.process_read
        self._processMap["read_json"] = Processor.process_read_json
        self._processMap["query_aggregate"] = Processor.process_query_aggregate
        self._processMap["adhoc_aggregate"] = Processor.process_adhoc_aggregate
        self._processMap["adhoc_filter"] = Processor.process_adhoc_filter
        self._processMap["predef_filter"] = Processor.process_predef_filter
        self._processMap["combined_filter"] = Processor.process_combined_filter
        self._processMap["alerts_by_time"] = Processor.process_alerts_by_time
        self._processMap["alerts_by_trigger_and_time"] = Processor.process_alerts_by_trigger_and_time
        self._processMap["get_more"] = Processor.process_get_more
        self._processMap["num_records"] = Processor.process_num_records

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_register_handler(self, seqid, iprot, oprot):
        args = register_handler_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = register_handler_result()
        try:
            self._handler.register_handler()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_management_exception as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("register_handler", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deregister_handler(self, seqid, iprot, oprot):
        args = deregister_handler_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deregister_handler_result()
        try:
            self._handler.deregister_handler()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_management_exception as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deregister_handler", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_atomic_multilog(self, seqid, iprot, oprot):
        args = create_atomic_multilog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_atomic_multilog_result()
        try:
            result.success = self._handler.create_atomic_multilog(args.name, args.schema, args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_management_exception as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_atomic_multilog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_atomic_multilog_info(self, seqid, iprot, oprot):
        args = get_atomic_multilog_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_atomic_multilog_info_result()
        try:
            result.success = self._handler.get_atomic_multilog_info(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_atomic_multilog_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_atomic_multilog(self, seqid, iprot, oprot):
        args = remove_atomic_multilog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_atomic_multilog_result()
        try:
            self._handler.remove_atomic_multilog(args.multilog_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_management_exception as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_atomic_multilog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_index(self, seqid, iprot, oprot):
        args = add_index_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_index_result()
        try:
            self._handler.add_index(args.multilog_id, args.field_name, args.bucket_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_management_exception as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_index", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_index(self, seqid, iprot, oprot):
        args = remove_index_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_index_result()
        try:
            self._handler.remove_index(args.multilog_id, args.field_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_management_exception as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_index", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_filter(self, seqid, iprot, oprot):
        args = add_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_filter_result()
        try:
            self._handler.add_filter(args.multilog_id, args.filter_name, args.filter_expr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_management_exception as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_filter(self, seqid, iprot, oprot):
        args = remove_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_filter_result()
        try:
            self._handler.remove_filter(args.multilog_id, args.filter_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_management_exception as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_aggregate(self, seqid, iprot, oprot):
        args = add_aggregate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_aggregate_result()
        try:
            self._handler.add_aggregate(args.mutlilog_id, args.aggregate_name, args.filter_name, args.aggregate_expr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_management_exception as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_aggregate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_aggregate(self, seqid, iprot, oprot):
        args = remove_aggregate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_aggregate_result()
        try:
            self._handler.remove_aggregate(args.multilog_id, args.aggregate_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_aggregate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_trigger(self, seqid, iprot, oprot):
        args = add_trigger_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_trigger_result()
        try:
            self._handler.add_trigger(args.multilog_id, args.trigger_name, args.trigger_expr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_management_exception as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_trigger", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_trigger(self, seqid, iprot, oprot):
        args = remove_trigger_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_trigger_result()
        try:
            self._handler.remove_trigger(args.multilog_id, args.trigger_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_management_exception as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_trigger", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append(self, seqid, iprot, oprot):
        args = append_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_result()
        try:
            result.success = self._handler.append(args.multilog_id, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("append", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_json(self, seqid, iprot, oprot):
        args = append_json_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_json_result()
        try:
            result.success = self._handler.append_json(args.multilog_id, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("append_json", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_batch(self, seqid, iprot, oprot):
        args = append_batch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_batch_result()
        try:
            result.success = self._handler.append_batch(args.multilog_id, args.batch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("append_batch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read(self, seqid, iprot, oprot):
        args = read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_result()
        try:
            result.success = self._handler.read(args.multilog_id, args.offset, args.nrecords)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_json(self, seqid, iprot, oprot):
        args = read_json_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_json_result()
        try:
            result.success = self._handler.read_json(args.multilog_id, args.offset, args.nrecords)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_json", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_aggregate(self, seqid, iprot, oprot):
        args = query_aggregate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_aggregate_result()
        try:
            result.success = self._handler.query_aggregate(args.multilog_id, args.aggregate_name, args.begin_ms, args.end_ms)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_invalid_operation as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_aggregate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_adhoc_aggregate(self, seqid, iprot, oprot):
        args = adhoc_aggregate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = adhoc_aggregate_result()
        try:
            result.success = self._handler.adhoc_aggregate(args.multilog_id, args.aggregate_expr, args.filter_expr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_invalid_operation as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("adhoc_aggregate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_adhoc_filter(self, seqid, iprot, oprot):
        args = adhoc_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = adhoc_filter_result()
        try:
            result.success = self._handler.adhoc_filter(args.multilog_id, args.filter_expr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_invalid_operation as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("adhoc_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_predef_filter(self, seqid, iprot, oprot):
        args = predef_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = predef_filter_result()
        try:
            result.success = self._handler.predef_filter(args.multilog_id, args.filter_name, args.begin_ms, args.end_ms)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_invalid_operation as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("predef_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_combined_filter(self, seqid, iprot, oprot):
        args = combined_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = combined_filter_result()
        try:
            result.success = self._handler.combined_filter(args.multilog_id, args.filter_name, args.filter_expr, args.begin_ms, args.end_ms)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_invalid_operation as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("combined_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alerts_by_time(self, seqid, iprot, oprot):
        args = alerts_by_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alerts_by_time_result()
        try:
            result.success = self._handler.alerts_by_time(args.multilog_id, args.begin_ms, args.end_ms)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_invalid_operation as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alerts_by_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alerts_by_trigger_and_time(self, seqid, iprot, oprot):
        args = alerts_by_trigger_and_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alerts_by_trigger_and_time_result()
        try:
            result.success = self._handler.alerts_by_trigger_and_time(args.multilog_id, args.trigger_name, args.begin_ms, args.end_ms)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_invalid_operation as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alerts_by_trigger_and_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_more(self, seqid, iprot, oprot):
        args = get_more_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_more_result()
        try:
            result.success = self._handler.get_more(args.multilog_id, args.desc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except rpc_invalid_operation as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_more", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_num_records(self, seqid, iprot, oprot):
        args = num_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = num_records_result()
        try:
            result.success = self._handler.num_records(args.multilog_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("num_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class register_handler_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('register_handler_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(register_handler_args)
register_handler_args.thrift_spec = (
)


class register_handler_result(object):
    """
    Attributes:
     - ex
    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_management_exception()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('register_handler_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(register_handler_result)
register_handler_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [rpc_management_exception, None], None, ),  # 1
)


class deregister_handler_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deregister_handler_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deregister_handler_args)
deregister_handler_args.thrift_spec = (
)


class deregister_handler_result(object):
    """
    Attributes:
     - ex
    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_management_exception()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deregister_handler_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deregister_handler_result)
deregister_handler_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [rpc_management_exception, None], None, ),  # 1
)


class create_atomic_multilog_args(object):
    """
    Attributes:
     - name
     - schema
     - mode
    """


    def __init__(self, name=None, schema=None, mode=None,):
        self.name = name
        self.schema = schema
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.schema = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = rpc_column()
                        _elem19.read(iprot)
                        self.schema.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_atomic_multilog_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.schema is not None:
            oprot.writeFieldBegin('schema', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.schema))
            for iter20 in self.schema:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 3)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_atomic_multilog_args)
create_atomic_multilog_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'schema', (TType.STRUCT, [rpc_column, None], False), None, ),  # 2
    (3, TType.I32, 'mode', None, None, ),  # 3
)


class create_atomic_multilog_result(object):
    """
    Attributes:
     - success
     - ex
    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_management_exception()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_atomic_multilog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_atomic_multilog_result)
create_atomic_multilog_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ex', [rpc_management_exception, None], None, ),  # 1
)


class get_atomic_multilog_info_args(object):
    """
    Attributes:
     - name
    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_atomic_multilog_info_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_atomic_multilog_info_args)
get_atomic_multilog_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class get_atomic_multilog_info_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = rpc_atomic_multilog_info()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_atomic_multilog_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_atomic_multilog_info_result)
get_atomic_multilog_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [rpc_atomic_multilog_info, None], None, ),  # 0
)


class remove_atomic_multilog_args(object):
    """
    Attributes:
     - multilog_id
    """


    def __init__(self, multilog_id=None,):
        self.multilog_id = multilog_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_atomic_multilog_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_atomic_multilog_args)
remove_atomic_multilog_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
)


class remove_atomic_multilog_result(object):
    """
    Attributes:
     - ex
    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_management_exception()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_atomic_multilog_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_atomic_multilog_result)
remove_atomic_multilog_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [rpc_management_exception, None], None, ),  # 1
)


class add_index_args(object):
    """
    Attributes:
     - multilog_id
     - field_name
     - bucket_size
    """


    def __init__(self, multilog_id=None, field_name=None, bucket_size=None,):
        self.multilog_id = multilog_id
        self.field_name = field_name
        self.bucket_size = bucket_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.field_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.bucket_size = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_index_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.field_name is not None:
            oprot.writeFieldBegin('field_name', TType.STRING, 2)
            oprot.writeString(self.field_name.encode('utf-8') if sys.version_info[0] == 2 else self.field_name)
            oprot.writeFieldEnd()
        if self.bucket_size is not None:
            oprot.writeFieldBegin('bucket_size', TType.DOUBLE, 3)
            oprot.writeDouble(self.bucket_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_index_args)
add_index_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'field_name', 'UTF8', None, ),  # 2
    (3, TType.DOUBLE, 'bucket_size', None, None, ),  # 3
)


class add_index_result(object):
    """
    Attributes:
     - ex
    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_management_exception()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_index_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_index_result)
add_index_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [rpc_management_exception, None], None, ),  # 1
)


class remove_index_args(object):
    """
    Attributes:
     - multilog_id
     - field_name
    """


    def __init__(self, multilog_id=None, field_name=None,):
        self.multilog_id = multilog_id
        self.field_name = field_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.field_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_index_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.field_name is not None:
            oprot.writeFieldBegin('field_name', TType.STRING, 2)
            oprot.writeString(self.field_name.encode('utf-8') if sys.version_info[0] == 2 else self.field_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_index_args)
remove_index_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'field_name', 'UTF8', None, ),  # 2
)


class remove_index_result(object):
    """
    Attributes:
     - ex
    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_management_exception()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_index_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_index_result)
remove_index_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [rpc_management_exception, None], None, ),  # 1
)


class add_filter_args(object):
    """
    Attributes:
     - multilog_id
     - filter_name
     - filter_expr
    """


    def __init__(self, multilog_id=None, filter_name=None, filter_expr=None,):
        self.multilog_id = multilog_id
        self.filter_name = filter_name
        self.filter_expr = filter_expr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filter_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter_expr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_filter_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.filter_name is not None:
            oprot.writeFieldBegin('filter_name', TType.STRING, 2)
            oprot.writeString(self.filter_name.encode('utf-8') if sys.version_info[0] == 2 else self.filter_name)
            oprot.writeFieldEnd()
        if self.filter_expr is not None:
            oprot.writeFieldBegin('filter_expr', TType.STRING, 3)
            oprot.writeString(self.filter_expr.encode('utf-8') if sys.version_info[0] == 2 else self.filter_expr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_filter_args)
add_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'filter_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'filter_expr', 'UTF8', None, ),  # 3
)


class add_filter_result(object):
    """
    Attributes:
     - ex
    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_management_exception()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_filter_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_filter_result)
add_filter_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [rpc_management_exception, None], None, ),  # 1
)


class remove_filter_args(object):
    """
    Attributes:
     - multilog_id
     - filter_name
    """


    def __init__(self, multilog_id=None, filter_name=None,):
        self.multilog_id = multilog_id
        self.filter_name = filter_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filter_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_filter_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.filter_name is not None:
            oprot.writeFieldBegin('filter_name', TType.STRING, 2)
            oprot.writeString(self.filter_name.encode('utf-8') if sys.version_info[0] == 2 else self.filter_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_filter_args)
remove_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'filter_name', 'UTF8', None, ),  # 2
)


class remove_filter_result(object):
    """
    Attributes:
     - ex
    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_management_exception()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_filter_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_filter_result)
remove_filter_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [rpc_management_exception, None], None, ),  # 1
)


class add_aggregate_args(object):
    """
    Attributes:
     - mutlilog_id
     - aggregate_name
     - filter_name
     - aggregate_expr
    """


    def __init__(self, mutlilog_id=None, aggregate_name=None, filter_name=None, aggregate_expr=None,):
        self.mutlilog_id = mutlilog_id
        self.aggregate_name = aggregate_name
        self.filter_name = filter_name
        self.aggregate_expr = aggregate_expr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mutlilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.aggregate_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.aggregate_expr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_aggregate_args')
        if self.mutlilog_id is not None:
            oprot.writeFieldBegin('mutlilog_id', TType.I64, 1)
            oprot.writeI64(self.mutlilog_id)
            oprot.writeFieldEnd()
        if self.aggregate_name is not None:
            oprot.writeFieldBegin('aggregate_name', TType.STRING, 2)
            oprot.writeString(self.aggregate_name.encode('utf-8') if sys.version_info[0] == 2 else self.aggregate_name)
            oprot.writeFieldEnd()
        if self.filter_name is not None:
            oprot.writeFieldBegin('filter_name', TType.STRING, 3)
            oprot.writeString(self.filter_name.encode('utf-8') if sys.version_info[0] == 2 else self.filter_name)
            oprot.writeFieldEnd()
        if self.aggregate_expr is not None:
            oprot.writeFieldBegin('aggregate_expr', TType.STRING, 4)
            oprot.writeString(self.aggregate_expr.encode('utf-8') if sys.version_info[0] == 2 else self.aggregate_expr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_aggregate_args)
add_aggregate_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mutlilog_id', None, None, ),  # 1
    (2, TType.STRING, 'aggregate_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'filter_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'aggregate_expr', 'UTF8', None, ),  # 4
)


class add_aggregate_result(object):
    """
    Attributes:
     - ex
    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_management_exception()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_aggregate_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_aggregate_result)
add_aggregate_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [rpc_management_exception, None], None, ),  # 1
)


class remove_aggregate_args(object):
    """
    Attributes:
     - multilog_id
     - aggregate_name
    """


    def __init__(self, multilog_id=None, aggregate_name=None,):
        self.multilog_id = multilog_id
        self.aggregate_name = aggregate_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.aggregate_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_aggregate_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.aggregate_name is not None:
            oprot.writeFieldBegin('aggregate_name', TType.STRING, 2)
            oprot.writeString(self.aggregate_name.encode('utf-8') if sys.version_info[0] == 2 else self.aggregate_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_aggregate_args)
remove_aggregate_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'aggregate_name', 'UTF8', None, ),  # 2
)


class remove_aggregate_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_aggregate_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_aggregate_result)
remove_aggregate_result.thrift_spec = (
)


class add_trigger_args(object):
    """
    Attributes:
     - multilog_id
     - trigger_name
     - trigger_expr
    """


    def __init__(self, multilog_id=None, trigger_name=None, trigger_expr=None,):
        self.multilog_id = multilog_id
        self.trigger_name = trigger_name
        self.trigger_expr = trigger_expr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.trigger_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.trigger_expr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_trigger_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.trigger_name is not None:
            oprot.writeFieldBegin('trigger_name', TType.STRING, 2)
            oprot.writeString(self.trigger_name.encode('utf-8') if sys.version_info[0] == 2 else self.trigger_name)
            oprot.writeFieldEnd()
        if self.trigger_expr is not None:
            oprot.writeFieldBegin('trigger_expr', TType.STRING, 3)
            oprot.writeString(self.trigger_expr.encode('utf-8') if sys.version_info[0] == 2 else self.trigger_expr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_trigger_args)
add_trigger_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'trigger_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'trigger_expr', 'UTF8', None, ),  # 3
)


class add_trigger_result(object):
    """
    Attributes:
     - ex
    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_management_exception()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_trigger_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_trigger_result)
add_trigger_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [rpc_management_exception, None], None, ),  # 1
)


class remove_trigger_args(object):
    """
    Attributes:
     - multilog_id
     - trigger_name
    """


    def __init__(self, multilog_id=None, trigger_name=None,):
        self.multilog_id = multilog_id
        self.trigger_name = trigger_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.trigger_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_trigger_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.trigger_name is not None:
            oprot.writeFieldBegin('trigger_name', TType.STRING, 2)
            oprot.writeString(self.trigger_name.encode('utf-8') if sys.version_info[0] == 2 else self.trigger_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_trigger_args)
remove_trigger_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'trigger_name', 'UTF8', None, ),  # 2
)


class remove_trigger_result(object):
    """
    Attributes:
     - ex
    """


    def __init__(self, ex=None,):
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_management_exception()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_trigger_result')
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_trigger_result)
remove_trigger_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ex', [rpc_management_exception, None], None, ),  # 1
)


class append_args(object):
    """
    Attributes:
     - multilog_id
     - data
    """


    def __init__(self, multilog_id=None, data=None,):
        self.multilog_id = multilog_id
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 2)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_args)
append_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'data', 'BINARY', None, ),  # 2
)


class append_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_result)
append_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class append_json_args(object):
    """
    Attributes:
     - multilog_id
     - data
    """


    def __init__(self, multilog_id=None, data=None,):
        self.multilog_id = multilog_id
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.data = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_json_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 2)
            oprot.writeString(self.data.encode('utf-8') if sys.version_info[0] == 2 else self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_json_args)
append_json_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'data', 'UTF8', None, ),  # 2
)


class append_json_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_json_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_json_result)
append_json_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class append_batch_args(object):
    """
    Attributes:
     - multilog_id
     - batch
    """


    def __init__(self, multilog_id=None, batch=None,):
        self.multilog_id = multilog_id
        self.batch = batch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.batch = rpc_record_batch()
                    self.batch.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_batch_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.batch is not None:
            oprot.writeFieldBegin('batch', TType.STRUCT, 2)
            self.batch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_batch_args)
append_batch_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRUCT, 'batch', [rpc_record_batch, None], None, ),  # 2
)


class append_batch_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('append_batch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(append_batch_result)
append_batch_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class read_args(object):
    """
    Attributes:
     - multilog_id
     - offset
     - nrecords
    """


    def __init__(self, multilog_id=None, offset=None, nrecords=None,):
        self.multilog_id = multilog_id
        self.offset = offset
        self.nrecords = nrecords

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.nrecords = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 2)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.nrecords is not None:
            oprot.writeFieldBegin('nrecords', TType.I64, 3)
            oprot.writeI64(self.nrecords)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_args)
read_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.I64, 'offset', None, None, ),  # 2
    (3, TType.I64, 'nrecords', None, None, ),  # 3
)


class read_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_result)
read_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class read_json_args(object):
    """
    Attributes:
     - multilog_id
     - offset
     - nrecords
    """


    def __init__(self, multilog_id=None, offset=None, nrecords=None,):
        self.multilog_id = multilog_id
        self.offset = offset
        self.nrecords = nrecords

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.nrecords = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_json_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 2)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.nrecords is not None:
            oprot.writeFieldBegin('nrecords', TType.I64, 3)
            oprot.writeI64(self.nrecords)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_json_args)
read_json_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.I64, 'offset', None, None, ),  # 2
    (3, TType.I64, 'nrecords', None, None, ),  # 3
)


class read_json_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_json_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_json_result)
read_json_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class query_aggregate_args(object):
    """
    Attributes:
     - multilog_id
     - aggregate_name
     - begin_ms
     - end_ms
    """


    def __init__(self, multilog_id=None, aggregate_name=None, begin_ms=None, end_ms=None,):
        self.multilog_id = multilog_id
        self.aggregate_name = aggregate_name
        self.begin_ms = begin_ms
        self.end_ms = end_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.aggregate_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.begin_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.end_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_aggregate_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.aggregate_name is not None:
            oprot.writeFieldBegin('aggregate_name', TType.STRING, 2)
            oprot.writeString(self.aggregate_name.encode('utf-8') if sys.version_info[0] == 2 else self.aggregate_name)
            oprot.writeFieldEnd()
        if self.begin_ms is not None:
            oprot.writeFieldBegin('begin_ms', TType.I64, 3)
            oprot.writeI64(self.begin_ms)
            oprot.writeFieldEnd()
        if self.end_ms is not None:
            oprot.writeFieldBegin('end_ms', TType.I64, 4)
            oprot.writeI64(self.end_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_aggregate_args)
query_aggregate_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'aggregate_name', 'UTF8', None, ),  # 2
    (3, TType.I64, 'begin_ms', None, None, ),  # 3
    (4, TType.I64, 'end_ms', None, None, ),  # 4
)


class query_aggregate_result(object):
    """
    Attributes:
     - success
     - ex
    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_invalid_operation()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_aggregate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_aggregate_result)
query_aggregate_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ex', [rpc_invalid_operation, None], None, ),  # 1
)


class adhoc_aggregate_args(object):
    """
    Attributes:
     - multilog_id
     - aggregate_expr
     - filter_expr
    """


    def __init__(self, multilog_id=None, aggregate_expr=None, filter_expr=None,):
        self.multilog_id = multilog_id
        self.aggregate_expr = aggregate_expr
        self.filter_expr = filter_expr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.aggregate_expr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter_expr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('adhoc_aggregate_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.aggregate_expr is not None:
            oprot.writeFieldBegin('aggregate_expr', TType.STRING, 2)
            oprot.writeString(self.aggregate_expr.encode('utf-8') if sys.version_info[0] == 2 else self.aggregate_expr)
            oprot.writeFieldEnd()
        if self.filter_expr is not None:
            oprot.writeFieldBegin('filter_expr', TType.STRING, 3)
            oprot.writeString(self.filter_expr.encode('utf-8') if sys.version_info[0] == 2 else self.filter_expr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(adhoc_aggregate_args)
adhoc_aggregate_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'aggregate_expr', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'filter_expr', 'UTF8', None, ),  # 3
)


class adhoc_aggregate_result(object):
    """
    Attributes:
     - success
     - ex
    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_invalid_operation()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('adhoc_aggregate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(adhoc_aggregate_result)
adhoc_aggregate_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ex', [rpc_invalid_operation, None], None, ),  # 1
)


class adhoc_filter_args(object):
    """
    Attributes:
     - multilog_id
     - filter_expr
    """


    def __init__(self, multilog_id=None, filter_expr=None,):
        self.multilog_id = multilog_id
        self.filter_expr = filter_expr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filter_expr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('adhoc_filter_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.filter_expr is not None:
            oprot.writeFieldBegin('filter_expr', TType.STRING, 2)
            oprot.writeString(self.filter_expr.encode('utf-8') if sys.version_info[0] == 2 else self.filter_expr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(adhoc_filter_args)
adhoc_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'filter_expr', 'UTF8', None, ),  # 2
)


class adhoc_filter_result(object):
    """
    Attributes:
     - success
     - ex
    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = rpc_iterator_handle()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_invalid_operation()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('adhoc_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(adhoc_filter_result)
adhoc_filter_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [rpc_iterator_handle, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [rpc_invalid_operation, None], None, ),  # 1
)


class predef_filter_args(object):
    """
    Attributes:
     - multilog_id
     - filter_name
     - begin_ms
     - end_ms
    """


    def __init__(self, multilog_id=None, filter_name=None, begin_ms=None, end_ms=None,):
        self.multilog_id = multilog_id
        self.filter_name = filter_name
        self.begin_ms = begin_ms
        self.end_ms = end_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filter_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.begin_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.end_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('predef_filter_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.filter_name is not None:
            oprot.writeFieldBegin('filter_name', TType.STRING, 2)
            oprot.writeString(self.filter_name.encode('utf-8') if sys.version_info[0] == 2 else self.filter_name)
            oprot.writeFieldEnd()
        if self.begin_ms is not None:
            oprot.writeFieldBegin('begin_ms', TType.I64, 3)
            oprot.writeI64(self.begin_ms)
            oprot.writeFieldEnd()
        if self.end_ms is not None:
            oprot.writeFieldBegin('end_ms', TType.I64, 4)
            oprot.writeI64(self.end_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(predef_filter_args)
predef_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'filter_name', 'UTF8', None, ),  # 2
    (3, TType.I64, 'begin_ms', None, None, ),  # 3
    (4, TType.I64, 'end_ms', None, None, ),  # 4
)


class predef_filter_result(object):
    """
    Attributes:
     - success
     - ex
    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = rpc_iterator_handle()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_invalid_operation()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('predef_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(predef_filter_result)
predef_filter_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [rpc_iterator_handle, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [rpc_invalid_operation, None], None, ),  # 1
)


class combined_filter_args(object):
    """
    Attributes:
     - multilog_id
     - filter_name
     - filter_expr
     - begin_ms
     - end_ms
    """


    def __init__(self, multilog_id=None, filter_name=None, filter_expr=None, begin_ms=None, end_ms=None,):
        self.multilog_id = multilog_id
        self.filter_name = filter_name
        self.filter_expr = filter_expr
        self.begin_ms = begin_ms
        self.end_ms = end_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filter_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter_expr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.begin_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.end_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('combined_filter_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.filter_name is not None:
            oprot.writeFieldBegin('filter_name', TType.STRING, 2)
            oprot.writeString(self.filter_name.encode('utf-8') if sys.version_info[0] == 2 else self.filter_name)
            oprot.writeFieldEnd()
        if self.filter_expr is not None:
            oprot.writeFieldBegin('filter_expr', TType.STRING, 3)
            oprot.writeString(self.filter_expr.encode('utf-8') if sys.version_info[0] == 2 else self.filter_expr)
            oprot.writeFieldEnd()
        if self.begin_ms is not None:
            oprot.writeFieldBegin('begin_ms', TType.I64, 4)
            oprot.writeI64(self.begin_ms)
            oprot.writeFieldEnd()
        if self.end_ms is not None:
            oprot.writeFieldBegin('end_ms', TType.I64, 5)
            oprot.writeI64(self.end_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(combined_filter_args)
combined_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'filter_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'filter_expr', 'UTF8', None, ),  # 3
    (4, TType.I64, 'begin_ms', None, None, ),  # 4
    (5, TType.I64, 'end_ms', None, None, ),  # 5
)


class combined_filter_result(object):
    """
    Attributes:
     - success
     - ex
    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = rpc_iterator_handle()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_invalid_operation()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('combined_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(combined_filter_result)
combined_filter_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [rpc_iterator_handle, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [rpc_invalid_operation, None], None, ),  # 1
)


class alerts_by_time_args(object):
    """
    Attributes:
     - multilog_id
     - begin_ms
     - end_ms
    """


    def __init__(self, multilog_id=None, begin_ms=None, end_ms=None,):
        self.multilog_id = multilog_id
        self.begin_ms = begin_ms
        self.end_ms = end_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.begin_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.end_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alerts_by_time_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.begin_ms is not None:
            oprot.writeFieldBegin('begin_ms', TType.I64, 2)
            oprot.writeI64(self.begin_ms)
            oprot.writeFieldEnd()
        if self.end_ms is not None:
            oprot.writeFieldBegin('end_ms', TType.I64, 3)
            oprot.writeI64(self.end_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alerts_by_time_args)
alerts_by_time_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.I64, 'begin_ms', None, None, ),  # 2
    (3, TType.I64, 'end_ms', None, None, ),  # 3
)


class alerts_by_time_result(object):
    """
    Attributes:
     - success
     - ex
    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = rpc_iterator_handle()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_invalid_operation()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alerts_by_time_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alerts_by_time_result)
alerts_by_time_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [rpc_iterator_handle, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [rpc_invalid_operation, None], None, ),  # 1
)


class alerts_by_trigger_and_time_args(object):
    """
    Attributes:
     - multilog_id
     - trigger_name
     - begin_ms
     - end_ms
    """


    def __init__(self, multilog_id=None, trigger_name=None, begin_ms=None, end_ms=None,):
        self.multilog_id = multilog_id
        self.trigger_name = trigger_name
        self.begin_ms = begin_ms
        self.end_ms = end_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.trigger_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.begin_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.end_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alerts_by_trigger_and_time_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.trigger_name is not None:
            oprot.writeFieldBegin('trigger_name', TType.STRING, 2)
            oprot.writeString(self.trigger_name.encode('utf-8') if sys.version_info[0] == 2 else self.trigger_name)
            oprot.writeFieldEnd()
        if self.begin_ms is not None:
            oprot.writeFieldBegin('begin_ms', TType.I64, 3)
            oprot.writeI64(self.begin_ms)
            oprot.writeFieldEnd()
        if self.end_ms is not None:
            oprot.writeFieldBegin('end_ms', TType.I64, 4)
            oprot.writeI64(self.end_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alerts_by_trigger_and_time_args)
alerts_by_trigger_and_time_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRING, 'trigger_name', 'UTF8', None, ),  # 2
    (3, TType.I64, 'begin_ms', None, None, ),  # 3
    (4, TType.I64, 'end_ms', None, None, ),  # 4
)


class alerts_by_trigger_and_time_result(object):
    """
    Attributes:
     - success
     - ex
    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = rpc_iterator_handle()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_invalid_operation()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alerts_by_trigger_and_time_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alerts_by_trigger_and_time_result)
alerts_by_trigger_and_time_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [rpc_iterator_handle, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [rpc_invalid_operation, None], None, ),  # 1
)


class get_more_args(object):
    """
    Attributes:
     - multilog_id
     - desc
    """


    def __init__(self, multilog_id=None, desc=None,):
        self.multilog_id = multilog_id
        self.desc = desc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.desc = rpc_iterator_descriptor()
                    self.desc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_more_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        if self.desc is not None:
            oprot.writeFieldBegin('desc', TType.STRUCT, 2)
            self.desc.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_more_args)
get_more_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
    (2, TType.STRUCT, 'desc', [rpc_iterator_descriptor, None], None, ),  # 2
)


class get_more_result(object):
    """
    Attributes:
     - success
     - ex
    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = rpc_iterator_handle()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = rpc_invalid_operation()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_more_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_more_result)
get_more_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [rpc_iterator_handle, None], None, ),  # 0
    (1, TType.STRUCT, 'ex', [rpc_invalid_operation, None], None, ),  # 1
)


class num_records_args(object):
    """
    Attributes:
     - multilog_id
    """


    def __init__(self, multilog_id=None,):
        self.multilog_id = multilog_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.multilog_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('num_records_args')
        if self.multilog_id is not None:
            oprot.writeFieldBegin('multilog_id', TType.I64, 1)
            oprot.writeI64(self.multilog_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(num_records_args)
num_records_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'multilog_id', None, None, ),  # 1
)


class num_records_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('num_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(num_records_result)
num_records_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)
fix_spec(all_structs)
del all_structs

