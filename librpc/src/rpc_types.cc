/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "rpc_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace confluo { namespace rpc {

int _krpc_storage_modeValues[] = {
  RPC_IN_MEMORY,
  RPC_DURABLE_RELAXED,
  RPC_DURABLE
};
const char* _krpc_storage_modeNames[] = {
  "RPC_IN_MEMORY",
  "RPC_DURABLE_RELAXED",
  "RPC_DURABLE"
};
const std::map<int, const char*> _rpc_storage_mode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _krpc_storage_modeValues, _krpc_storage_modeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const rpc_storage_mode val) {
  std::map<int, const char*>::const_iterator it = _rpc_storage_mode_VALUES_TO_NAMES.find(val);
  if (it != _rpc_storage_mode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _krpc_data_typeValues[] = {
  RPC_NONE,
  RPC_BOOL,
  RPC_CHAR,
  RPC_UCHAR,
  RPC_SHORT,
  RPC_USHORT,
  RPC_INT,
  RPC_UINT,
  RPC_LONG,
  RPC_ULONG,
  RPC_FLOAT,
  RPC_DOUBLE,
  RPC_STRING,
  RPC_RECORD,
  RPC_ALERT
};
const char* _krpc_data_typeNames[] = {
  "RPC_NONE",
  "RPC_BOOL",
  "RPC_CHAR",
  "RPC_UCHAR",
  "RPC_SHORT",
  "RPC_USHORT",
  "RPC_INT",
  "RPC_UINT",
  "RPC_LONG",
  "RPC_ULONG",
  "RPC_FLOAT",
  "RPC_DOUBLE",
  "RPC_STRING",
  "RPC_RECORD",
  "RPC_ALERT"
};
const std::map<int, const char*> _rpc_data_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(15, _krpc_data_typeValues, _krpc_data_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const rpc_data_type val) {
  std::map<int, const char*>::const_iterator it = _rpc_data_type_VALUES_TO_NAMES.find(val);
  if (it != _rpc_data_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _krpc_iterator_typeValues[] = {
  RPC_ADHOC,
  RPC_PREDEF,
  RPC_COMBINED,
  RPC_ALERTS
};
const char* _krpc_iterator_typeNames[] = {
  "RPC_ADHOC",
  "RPC_PREDEF",
  "RPC_COMBINED",
  "RPC_ALERTS"
};
const std::map<int, const char*> _rpc_iterator_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _krpc_iterator_typeValues, _krpc_iterator_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const rpc_iterator_type val) {
  std::map<int, const char*>::const_iterator it = _rpc_iterator_type_VALUES_TO_NAMES.find(val);
  if (it != _rpc_iterator_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


rpc_column::~rpc_column() throw() {
}


void rpc_column::__set_type_id(const int32_t val) {
  this->type_id = val;
}

void rpc_column::__set_type_size(const int32_t val) {
  this->type_size = val;
}

void rpc_column::__set_name(const std::string& val) {
  this->name = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_column& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_column &a, rpc_column &b) {
  using ::std::swap;
  swap(a.type_id, b.type_id);
  swap(a.type_size, b.type_size);
  swap(a.name, b.name);
}

rpc_column::rpc_column(const rpc_column& other0) {
  type_id = other0.type_id;
  type_size = other0.type_size;
  name = other0.name;
}
rpc_column& rpc_column::operator=(const rpc_column& other1) {
  type_id = other1.type_id;
  type_size = other1.type_size;
  name = other1.name;
  return *this;
}
void rpc_column::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_column(";
  out << "type_id=" << to_string(type_id);
  out << ", " << "type_size=" << to_string(type_size);
  out << ", " << "name=" << to_string(name);
  out << ")";
}


rpc_iterator_descriptor::~rpc_iterator_descriptor() throw() {
}


void rpc_iterator_descriptor::__set_id(const rpc_iterator_id val) {
  this->id = val;
}

void rpc_iterator_descriptor::__set_type(const rpc_iterator_type val) {
  this->type = val;
}

void rpc_iterator_descriptor::__set_data_type(const rpc_data_type val) {
  this->data_type = val;
}

void rpc_iterator_descriptor::__set_handler_id(const rpc_handler_id val) {
  this->handler_id = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_iterator_descriptor& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_iterator_descriptor &a, rpc_iterator_descriptor &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.data_type, b.data_type);
  swap(a.handler_id, b.handler_id);
}

rpc_iterator_descriptor::rpc_iterator_descriptor(const rpc_iterator_descriptor& other4) {
  id = other4.id;
  type = other4.type;
  data_type = other4.data_type;
  handler_id = other4.handler_id;
}
rpc_iterator_descriptor& rpc_iterator_descriptor::operator=(const rpc_iterator_descriptor& other5) {
  id = other5.id;
  type = other5.type;
  data_type = other5.data_type;
  handler_id = other5.handler_id;
  return *this;
}
void rpc_iterator_descriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_iterator_descriptor(";
  out << "id=" << to_string(id);
  out << ", " << "type=" << to_string(type);
  out << ", " << "data_type=" << to_string(data_type);
  out << ", " << "handler_id=" << to_string(handler_id);
  out << ")";
}


rpc_iterator_handle::~rpc_iterator_handle() throw() {
}


void rpc_iterator_handle::__set_desc(const rpc_iterator_descriptor& val) {
  this->desc = val;
}

void rpc_iterator_handle::__set_data(const std::string& val) {
  this->data = val;
}

void rpc_iterator_handle::__set_num_entries(const int32_t val) {
  this->num_entries = val;
}

void rpc_iterator_handle::__set_has_more(const bool val) {
  this->has_more = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_iterator_handle& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_iterator_handle &a, rpc_iterator_handle &b) {
  using ::std::swap;
  swap(a.desc, b.desc);
  swap(a.data, b.data);
  swap(a.num_entries, b.num_entries);
  swap(a.has_more, b.has_more);
}

rpc_iterator_handle::rpc_iterator_handle(const rpc_iterator_handle& other6) {
  desc = other6.desc;
  data = other6.data;
  num_entries = other6.num_entries;
  has_more = other6.has_more;
}
rpc_iterator_handle& rpc_iterator_handle::operator=(const rpc_iterator_handle& other7) {
  desc = other7.desc;
  data = other7.data;
  num_entries = other7.num_entries;
  has_more = other7.has_more;
  return *this;
}
void rpc_iterator_handle::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_iterator_handle(";
  out << "desc=" << to_string(desc);
  out << ", " << "data=" << to_string(data);
  out << ", " << "num_entries=" << to_string(num_entries);
  out << ", " << "has_more=" << to_string(has_more);
  out << ")";
}


rpc_record_block::~rpc_record_block() throw() {
}


void rpc_record_block::__set_time_block(const int64_t val) {
  this->time_block = val;
}

void rpc_record_block::__set_data(const std::string& val) {
  this->data = val;
}

void rpc_record_block::__set_nrecords(const int64_t val) {
  this->nrecords = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_record_block& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_record_block &a, rpc_record_block &b) {
  using ::std::swap;
  swap(a.time_block, b.time_block);
  swap(a.data, b.data);
  swap(a.nrecords, b.nrecords);
}

rpc_record_block::rpc_record_block(const rpc_record_block& other8) {
  time_block = other8.time_block;
  data = other8.data;
  nrecords = other8.nrecords;
}
rpc_record_block& rpc_record_block::operator=(const rpc_record_block& other9) {
  time_block = other9.time_block;
  data = other9.data;
  nrecords = other9.nrecords;
  return *this;
}
void rpc_record_block::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_record_block(";
  out << "time_block=" << to_string(time_block);
  out << ", " << "data=" << to_string(data);
  out << ", " << "nrecords=" << to_string(nrecords);
  out << ")";
}


rpc_record_batch::~rpc_record_batch() throw() {
}


void rpc_record_batch::__set_blocks(const std::vector<rpc_record_block> & val) {
  this->blocks = val;
}

void rpc_record_batch::__set_nrecords(const int64_t val) {
  this->nrecords = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_record_batch& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_record_batch &a, rpc_record_batch &b) {
  using ::std::swap;
  swap(a.blocks, b.blocks);
  swap(a.nrecords, b.nrecords);
}

rpc_record_batch::rpc_record_batch(const rpc_record_batch& other16) {
  blocks = other16.blocks;
  nrecords = other16.nrecords;
}
rpc_record_batch& rpc_record_batch::operator=(const rpc_record_batch& other17) {
  blocks = other17.blocks;
  nrecords = other17.nrecords;
  return *this;
}
void rpc_record_batch::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_record_batch(";
  out << "blocks=" << to_string(blocks);
  out << ", " << "nrecords=" << to_string(nrecords);
  out << ")";
}


rpc_atomic_multilog_info::~rpc_atomic_multilog_info() throw() {
}


void rpc_atomic_multilog_info::__set_id(const int64_t val) {
  this->id = val;
}

void rpc_atomic_multilog_info::__set_schema(const rpc_schema& val) {
  this->schema = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_atomic_multilog_info& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_atomic_multilog_info &a, rpc_atomic_multilog_info &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.schema, b.schema);
  swap(a.__isset, b.__isset);
}

rpc_atomic_multilog_info::rpc_atomic_multilog_info(const rpc_atomic_multilog_info& other24) {
  id = other24.id;
  schema = other24.schema;
  __isset = other24.__isset;
}
rpc_atomic_multilog_info& rpc_atomic_multilog_info::operator=(const rpc_atomic_multilog_info& other25) {
  id = other25.id;
  schema = other25.schema;
  __isset = other25.__isset;
  return *this;
}
void rpc_atomic_multilog_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_atomic_multilog_info(";
  out << "id=" << to_string(id);
  out << ", " << "schema=" << to_string(schema);
  out << ")";
}


rpc_management_exception::~rpc_management_exception() throw() {
}


void rpc_management_exception::__set_msg(const std::string& val) {
  this->msg = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_management_exception& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_management_exception &a, rpc_management_exception &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

rpc_management_exception::rpc_management_exception(const rpc_management_exception& other26) : TException() {
  msg = other26.msg;
  __isset = other26.__isset;
}
rpc_management_exception& rpc_management_exception::operator=(const rpc_management_exception& other27) {
  msg = other27.msg;
  __isset = other27.__isset;
  return *this;
}
void rpc_management_exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_management_exception(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* rpc_management_exception::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: rpc_management_exception";
  }
}


rpc_invalid_operation::~rpc_invalid_operation() throw() {
}


void rpc_invalid_operation::__set_msg(const std::string& val) {
  this->msg = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_invalid_operation& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_invalid_operation &a, rpc_invalid_operation &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

rpc_invalid_operation::rpc_invalid_operation(const rpc_invalid_operation& other28) : TException() {
  msg = other28.msg;
  __isset = other28.__isset;
}
rpc_invalid_operation& rpc_invalid_operation::operator=(const rpc_invalid_operation& other29) {
  msg = other29.msg;
  __isset = other29.__isset;
  return *this;
}
void rpc_invalid_operation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_invalid_operation(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* rpc_invalid_operation::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: rpc_invalid_operation";
  }
}

}} // namespace
