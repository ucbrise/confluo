// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "rpc_service.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::confluo::rpc;

class rpc_serviceHandler : virtual public rpc_serviceIf {
 public:
  rpc_serviceHandler() {
    // Your initialization goes here
  }

  /**
   * Management ops *
   */
  void register_handler() {
    // Your implementation goes here
    printf("register_handler\n");
  }

  void deregister_handler() {
    // Your implementation goes here
    printf("deregister_handler\n");
  }

  int64_t create_atomic_multilog(const std::string& name, const rpc_schema& schema, const rpc_storage_mode::type mode) {
    // Your implementation goes here
    printf("create_atomic_multilog\n");
  }

  void get_atomic_multilog_info(rpc_atomic_multilog_info& _return, const std::string& name) {
    // Your implementation goes here
    printf("get_atomic_multilog_info\n");
  }

  void remove_atomic_multilog(const int64_t multilog_id) {
    // Your implementation goes here
    printf("remove_atomic_multilog\n");
  }

  void run_command(const int64_t multilog_id, const std::string& json_command) {
    // Your implementation goes here
    printf("run_command\n");
  }

  void add_index(const int64_t multilog_id, const std::string& field_name, const double bucket_size) {
    // Your implementation goes here
    printf("add_index\n");
  }

  void remove_index(const int64_t multilog_id, const std::string& field_name) {
    // Your implementation goes here
    printf("remove_index\n");
  }

  void add_filter(const int64_t multilog_id, const std::string& filter_name, const std::string& filter_expr) {
    // Your implementation goes here
    printf("add_filter\n");
  }

  void remove_filter(const int64_t multilog_id, const std::string& filter_name) {
    // Your implementation goes here
    printf("remove_filter\n");
  }

  void add_aggregate(const int64_t mutlilog_id, const std::string& aggregate_name, const std::string& filter_name, const std::string& aggregate_expr) {
    // Your implementation goes here
    printf("add_aggregate\n");
  }

  void remove_aggregate(const int64_t multilog_id, const std::string& aggregate_name) {
    // Your implementation goes here
    printf("remove_aggregate\n");
  }

  void add_trigger(const int64_t multilog_id, const std::string& trigger_name, const std::string& trigger_expr) {
    // Your implementation goes here
    printf("add_trigger\n");
  }

  void remove_trigger(const int64_t multilog_id, const std::string& trigger_name) {
    // Your implementation goes here
    printf("remove_trigger\n");
  }

  /**
   * Query ops *
   * 
   * @param multilog_id
   * @param data
   */
  int64_t append(const int64_t multilog_id, const std::string& data) {
    // Your implementation goes here
    printf("append\n");
  }

  int64_t append_batch(const int64_t multilog_id, const rpc_record_batch& batch) {
    // Your implementation goes here
    printf("append_batch\n");
  }

  void read(std::string& _return, const int64_t multilog_id, const int64_t offset, const int64_t nrecords) {
    // Your implementation goes here
    printf("read\n");
  }

  void read_json(std::string& _return, const int64_t multilog_id, const int64_t offset) {
    // Your implementation goes here
    printf("read_json\n");
  }

  void query_aggregate(std::string& _return, const int64_t multilog_id, const std::string& aggregate_name, const int64_t begin_ms, const int64_t end_ms) {
    // Your implementation goes here
    printf("query_aggregate\n");
  }

  void adhoc_aggregate(std::string& _return, const int64_t multilog_id, const std::string& aggregate_expr, const std::string& filter_expr) {
    // Your implementation goes here
    printf("adhoc_aggregate\n");
  }

  void adhoc_filter(rpc_iterator_handle& _return, const int64_t multilog_id, const std::string& filter_expr) {
    // Your implementation goes here
    printf("adhoc_filter\n");
  }

  void predef_filter(rpc_iterator_handle& _return, const int64_t multilog_id, const std::string& filter_name, const int64_t begin_ms, const int64_t end_ms) {
    // Your implementation goes here
    printf("predef_filter\n");
  }

  void combined_filter(rpc_iterator_handle& _return, const int64_t multilog_id, const std::string& filter_name, const std::string& filter_expr, const int64_t begin_ms, const int64_t end_ms) {
    // Your implementation goes here
    printf("combined_filter\n");
  }

  void alerts_by_time(rpc_iterator_handle& _return, const int64_t multilog_id, const int64_t begin_ms, const int64_t end_ms) {
    // Your implementation goes here
    printf("alerts_by_time\n");
  }

  void alerts_by_trigger_and_time(rpc_iterator_handle& _return, const int64_t multilog_id, const std::string& trigger_name, const int64_t begin_ms, const int64_t end_ms) {
    // Your implementation goes here
    printf("alerts_by_trigger_and_time\n");
  }

  void get_more(rpc_iterator_handle& _return, const int64_t multilog_id, const rpc_iterator_descriptor& desc) {
    // Your implementation goes here
    printf("get_more\n");
  }

  int64_t num_records(const int64_t multilog_id) {
    // Your implementation goes here
    printf("num_records\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  ::apache::thrift::stdcxx::shared_ptr<rpc_serviceHandler> handler(new rpc_serviceHandler());
  ::apache::thrift::stdcxx::shared_ptr<TProcessor> processor(new rpc_serviceProcessor(handler));
  ::apache::thrift::stdcxx::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::apache::thrift::stdcxx::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::apache::thrift::stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

